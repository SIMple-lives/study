# 查找

## 顺序查找

**ASL：**平均查找长度![image-20240121090926732](/home/future/.config/Typora/typora-user-images/image-20240121090926732.png)

![image-20240121114126514](/home/future/.config/Typora/typora-user-images/image-20240121114126514.png)

顺序查找=(1+n)/2;

出现的概率乘以查找次数

## 有序表查找

**要求有序**

* 折半查找（二分查找）

  > mid=（left+right）/2；

  重点

* 插值查找

  > mid=left+（right-left)*(kry-a[left])/(a[right]-a[left]).

* 斐波那契查找

  ```c
  while(n>f[k]-1)
  {
  	k++;
  }
  for(int i=right;i<f[k]-1;i++)
  {
  	a[i]=a[right];
  }
  while(left<=right)
  {
  	mid=left+F[k-1]-1;
  }
  ```

![image-20240121113800289](/home/future/.config/Typora/typora-user-images/image-20240121113800289.png)

## 线性索引查找

### 稠密索引

稠密索引是指在线性索引中，将数据集中的每一个记录对应一个索引项。

对于稠密索引的索引表来说，索引项一定是按照关键码有序排列的.

索引项有序也就意昧着,我们要查找关键字时可以用到折半、插值、裴波那契等有序查找算法’大大提高了效率°我要查找关键字是l8的记录,如果直接从右侧的数据表中查找,那只能）顺序查找
需要查找6次才可以查至｜」结果°而如果是从左侧的索引表中查找’只需两次折半查找就可
以得到18对应的指针’最终查找至｜」结果。
这显然是稠密索引的优点’但是如果数据集非常大’比如上亿’那也就意昧着索弓｜
也得有同样的数据集长度规模’对干内存有限的计算机来说’可能就需要反复去访问磁
盘’查找性能反而大大下降了。

### 分块索引

将数据进行分块，类似于图书馆那样.

分块有序，是把数据集的记录分成了若干块，并且这些块需要满足以下两个条件：

* 块内无序：即每一块内的记录不要求有序。当然，有序会更加方便的查找，不过这就需要付出大量的时间与经历，因此通常不要求块内有序
* 块间有序：例如，要求第二块所有记录的关键字均要大于第一块中记录的关键字，第三块中的关键字均要大于第二块中记录的关键字。只要块间有序，才有可能在查找时提高效率。

![image-20240118172812525](/home/future/.config/Typora/typora-user-images/image-20240118172812525.png)

### 倒排索引

1. **基本概念：**
   - 倒排索引是一种将文档中的词语映射到文档ID的数据结构。每个词语都有一个对应的倒排列表，记录了包含该词语的文档ID。
2. **构建过程：**
   - 对于给定的文档集合，首先对每个文档进行分词，得到文档的词语列表。
   - 针对每个词语，记录包含该词语的文档ID。这个过程构建了倒排列表。
   - 最终，将所有词语的倒排列表组合成一个完整的倒排索引。
3. **查询过程：**
   - 当用户输入一个查询词语时，系统可以直接查找该词语在倒排索引中的倒排列表。
   - 倒排列表中记录了包含该词语的文档ID，通过这些文档ID可以快速定位相关文档。
4. **优点：**
   - 倒排索引可以快速定位包含特定词语的文档，提高信息检索的效率。
   - 在大规模文档集合中，倒排索引可以有效地减小搜索范围，提高搜索速度。
5. **应用：**
   - 倒排索引广泛应用于搜索引擎、文本检索系统、数据分析等领域。

以下是一个简单的示例，演示了如何构建一个简单的倒排索引：

```
文档1: "倒排索引是什么"
文档2: "倒排索引怎么用"
文档3: "倒排索引应用场景"

倒排索引:
{
  "倒排": [1, 2, 3],
  "索引": [1, 2, 3],
  "是": [1],
  "什么": [1],
  "怎么用": [2],
  "应用场景": [3]
}

```

## 二叉排序树

![image-20240118175400171](/home/future/.config/Typora/typora-user-images/image-20240118175400171.png)

排序二叉树的删除操作.

```
if(q!=*p)
{
	q->rchild=s->lchild;//这里的作用是后面含有右子树，那么用右子树的值替代删除结点后，替代结点的左子树应该做替代结点前驱的右子树
}
else
{
	q->lchild=s->lchild;//如过没有右子树，那么就直接就近替换并将树接起来.
}
```

## 平衡二叉树（AVL树）

平衡二叉树是一种二叉排序树，其中每一个结点的左子树和右子树的高度差至多等于1。

我们将二叉树上结点的左子树高度减去右子树高度的值称为平衡因子BF(Balance Factor).

## 多路查找树

其中每一个结点的孩子数可以多于两个，且每一个结点处可以存储多个元素.

### 2-3树

其中的每一个结点都具有两个孩子(2结点）或3个孩子.（3结点）

一个2结点包含一个元素和两个孩子（或没有孩子）

一个3结点包含一大一小两个元素和3个孩子（或没有孩子）

### 2-3-4树

在**2-3树**的基础上扩展了4结点。

一个4结点包含了小 中 大3个元素和4个孩子（或没有孩子）（**所有的关系都是要么没有孩子，要么就必须拥有当前结点所要求的孩子数目**）

![image-20240118193829793](/home/future/.config/Typora/typora-user-images/image-20240118193829793.png)

![image-20240118193817875](/home/future/.config/Typora/typora-user-images/image-20240118193817875.png)

### B树

B树是一种平衡的多路查找树.2-3树和2-3-4树都是B树的特例。

结点最大的孩子数目称为B树的阶》

![image-20240118200737522](/home/future/.config/Typora/typora-user-images/image-20240118200737522.png)

![image-20240121144930896](/home/future/.config/Typora/typora-user-images/image-20240121144930896.png)

![image-20240121150700756](/home/future/.config/Typora/typora-user-images/image-20240121150700756.png)

#### 代码实现

1.对应包含一个关键字的数组（比孩子多一个方便删除与插入）

2.孩子数组

3.关键字个数

4.孩子个数

5.保存父亲指针

6.树的阶数

![image-20240121151235081](/home/future/.config/Typora/typora-user-images/image-20240121151235081.png)



### B+树

![image-20240118202715523](/home/future/.config/Typora/typora-user-images/image-20240118202715523.png)



## 散列表查找（哈希表）概述

哈希表是根据关键码的值而直接进行访问的数据结构

散列技术是在记录的存储位置和他的关键字之间建立一个确定的关系f，使得每一个关键字key对应一个存储位置f(key).查找时，根据这个确定的对应关系找到给定值key的映射f（key），若查找集合中存在这个记录，则必定在f(key)的位置上.

![image-20240118204307101](/home/future/.config/Typora/typora-user-images/image-20240118204307101.png)

![image-20240118204554209](/home/future/.config/Typora/typora-user-images/image-20240118204554209.png)

适用于主关键字查找，即一个特定的关键字对应一个特定的地址与对象.

### 构造方法

两个原则

* 计算简单

  > 如果说设计一个算法可以保证所有的关键字都不会产生冲突，但是这个算法需要很复杂的计算，会耗费很多时间，这对于频繁的查找来说，就会大大降低查找的效率.
  >
  > 因此散列函数的计算时间不应该超过其他查找技术与关键字比较的时间

* 散列地址分布均匀

  > 我们刚才提到了冲突带来的问题，最好的颁发就是尽量让散列地址均匀地分布在存储空间中，这样可以保证存储空间的有效利用，并减少为处理冲突而消耗的时间.

### 直接定址法

![image-20240118205556631](/home/future/.config/Typora/typora-user-images/image-20240118205556631.png)

### 数字分析法

![image-20240118205813856](/home/future/.config/Typora/typora-user-images/image-20240118205813856.png)

### 平方取中法

![image-20240118205856981](/home/future/.config/Typora/typora-user-images/image-20240118205856981.png)

 ### 折叠法

![image-20240118205947453](/home/future/.config/Typora/typora-user-images/image-20240118205947453.png)

### 除留余数法

![image-20240118210211357](/home/future/.config/Typora/typora-user-images/image-20240118210211357.png)

### 随机数法

选择一个随机数，取关键字的随机函数值为他的散列地址.

## 处理散列表冲突的办法

### 开放定址法 

开放定址法就是一旦发生了冲突，就去寻找下一个空的散列地址，只要散列地址表足够大，空的散列地址总能够找到，并将记录存入.

### 在散列函数法

![image-20240118211022931](/home/future/.config/Typora/typora-user-images/image-20240118211022931.png)

### 链地址法

![image-20240118211110505](/home/future/.config/Typora/typora-user-images/image-20240118211110505.png)

### 公共溢出区法

![image-20240118211217133](/home/future/.config/Typora/typora-user-images/image-20240118211217133.png)

实现散列表

![image-20240118211457633](/home/future/.config/Typora/typora-user-images/image-20240118211457633.png)
